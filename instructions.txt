In-Memory Key-Value Store Challenge
Your Task
In this challenge, you’ll need to implement an in-memory key-value store. The store should allow basic operations like Get, Set and Delete.

Make sure to thoroughly review the requirements before starting and rely on your best judgement during implementation if anything is unspecified. We've intentionally kept this document concise to encourage your creative freedom and interpretation. This approach allows you to demonstrate your problem-solving abilities and innovative thinking.

What we're looking for
How you approach designing and implementing a service.
How you structure code to ensure it's well tested, easy to extend, easy to modify, easy to understand for others and that it complies with best practices for Go.
Documentation on how to build and run the project, specifically how to interact with the API. This information should be contained within the README.md file.
We don't expect you to write all the code required to solve this challenge, you're more than welcome to bring in other libraries to help you out.
Write notes! We'd love to have a glimpse into your thought process while tackling this challenge, tradeoffs you made in design choices, and thoughts that you have around how to improve upon the solution. Use the NOTES.md file for this.
Please remember to frequently pull your code into CodeSignal if you’re working outside of the platform. This helps us monitor your progress and understand your development process.
Some boilerplate code has been provided to speed up development. Feel free to edit or remove it as necessary to fit your specific use case.
⏳ The solution should be delivered at most in 7 days after you access the CodeSignal link provided.

What not to do
Don't prioritize writing perfect code or covering every logical path with tests over completing the task.
Requirements
Expose the Set, Get and Delete operations via an HTTP API:
GET /key/:key
If the key exists, return the key-value pair, for example {"key":"value"}.
If the key does not exist, return a not found message, for example {"message":"key not found"}.
POST /key
Should accept a payload like {"key":"value"} and return a message indicating if the operation was successful.
If the key does not exist, create the key-value pair and return a success message, for example {"message":"key created successfully"}.
If the key already exists, return a conflict message, for example {"message":"key already exists"}.
DELETE /key/:key
If the key exists, delete the key and return a success message, for example {"message":"key deleted successfully"}.
If the key does not exist, return a not found message, for example {"message":"key not found"}.
Keys should be unique.
Limit the length of keys to avoid excessively long strings that could impact performance.
Limit the size of values to avoid memory issues.
Implement detailed error messages and appropriate HTTP status codes for different failure scenarios.
Implement thread-safe operations to handle concurrent access to the key-value store.
Ensure the key-value store can handle a high number of requests per second.
Write a simple Go benchmark for the Set and Get operations, and describe what you would do to improve the benchmark results inside the NOTES.md file.
Create potential generated assets within the ./assets directory. Anything created within this directory will be ignored from the final submission.